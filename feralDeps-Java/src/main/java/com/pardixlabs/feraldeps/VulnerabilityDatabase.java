//this is currently a mock implementation of a DB

package com.pardixlabs.feraldeps;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class VulnerabilityDatabase {

    // Cache to avoid repeated API calls
    private static final Map<String, String> versionCache = new HashMap<>();
    private static final Map<String, Boolean> vulnerabilityCache = new HashMap<>();
    private static final Map<String, RemediationInfo> remediationCache = new HashMap<>();
    
    /**
     * Information about remediation for a vulnerable dependency
     */
    public static class RemediationInfo {
        public final List<String> fixedVersions;
        public final String summary;
        public final boolean hasRemediation;
        
        public RemediationInfo(List<String> fixedVersions, String summary) {
            this.fixedVersions = fixedVersions;
            this.summary = summary;
            this.hasRemediation = !fixedVersions.isEmpty();
        }
        
        public static RemediationInfo empty() {
            return new RemediationInfo(new ArrayList<>(), "No remediation information available");
        }
    }

    public static Optional<String> latestVersion(String coordinate) {
        // Check cache first
        if (versionCache.containsKey(coordinate)) {
            return Optional.ofNullable(versionCache.get(coordinate));
        }

        try {
            String[] parts = coordinate.split(":");
            if (parts.length != 2) return Optional.empty();
            
            String groupId = parts[0];
            String artifactId = parts[1];
            
            // Query Maven Central API
            String urlString = "https://search.maven.org/solrsearch/select?q=g:" + 
                groupId + "+AND+a:" + artifactId + "&rows=1&wt=json";
            
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);
            
            int responseCode = conn.getResponseCode();
            if (responseCode == 200) {
                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = in.readLine()) != null) {
                    response.append(line);
                }
                in.close();
                
                // Parse JSON response (simple string parsing to avoid dependencies)
                String json = response.toString();
                String latestVersion = extractLatestVersion(json);
                
                if (latestVersion != null) {
                    versionCache.put(coordinate, latestVersion);
                    return Optional.of(latestVersion);
                }
            }
        } catch (Exception e) {
            // Silently fail - API might be unreachable
            System.err.println("Failed to fetch latest version for " + coordinate + ": " + e.getMessage());
        }
        
        versionCache.put(coordinate, null);
        return Optional.empty();
    }

    public static boolean isVulnerable(Dependency dep) {
        String key = dep.coordinate() + ":" + dep.version;
        
        // Check cache first
        if (vulnerabilityCache.containsKey(key)) {
            return vulnerabilityCache.get(key);
        }

        try {
            // Query OSV (Open Source Vulnerabilities) API
            URL url = new URL("https://api.osv.dev/v1/query");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "application/json");
            conn.setDoOutput(true);
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);
            
            String jsonInputString = "{\"package\":{\"name\":\"" + dep.groupId + ":" + dep.artifactId + 
                "\",\"ecosystem\":\"Maven\"},\"version\":\"" + dep.version + "\"}";
            
            try (OutputStream os = conn.getOutputStream()) {
                byte[] input = jsonInputString.getBytes(StandardCharsets.UTF_8);
                os.write(input, 0, input.length);
            }
            
            int responseCode = conn.getResponseCode();
            if (responseCode == 200) {
                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = in.readLine()) != null) {
                    response.append(line);
                }
                in.close();
                
                // Check if response contains vulnerabilities
                String json = response.toString();
                boolean hasVulns = json.contains("\"vulns\"") && !json.contains("\"vulns\":[]");
                
                vulnerabilityCache.put(key, hasVulns);
                
                // Parse and cache remediation info if vulnerabilities exist
                if (hasVulns) {
                    RemediationInfo remediation = parseRemediationInfo(json);
                    remediationCache.put(key, remediation);
                }
                
                return hasVulns;
            }
        } catch (Exception e) {
            // Silently fail - API might be unreachable
            System.err.println("Failed to check vulnerabilities for " + key + ": " + e.getMessage());
        }
        
        vulnerabilityCache.put(key, false);
        return false;
    }
    
    /**
     * Get remediation information for a vulnerable dependency
     */
    public static Optional<RemediationInfo> getRemediationInfo(Dependency dep) {
        String key = dep.coordinate() + ":" + dep.version;
        
        // Check cache first
        if (remediationCache.containsKey(key)) {
            return Optional.of(remediationCache.get(key));
        }
        
        // If not cached, we need to call isVulnerable first which will populate the cache
        if (isVulnerable(dep) && remediationCache.containsKey(key)) {
            return Optional.of(remediationCache.get(key));
        }
        
        return Optional.empty();
    }
    
    /**
     * Parse remediation information from OSV API response
     */
    private static RemediationInfo parseRemediationInfo(String json) {
        List<String> fixedVersions = new ArrayList<>();
        StringBuilder summary = new StringBuilder();
        
        try {
            // Look for fixed versions in the response
            // OSV API returns affected ranges, we need to find the version that fixes the issue
            int affectedIndex = json.indexOf("\"affected\"");
            if (affectedIndex != -1) {
                // Extract ranges and find introduced/fixed versions
                String affectedSection = json.substring(affectedIndex);
                
                // Look for "fixed" field
                int fixedIndex = 0;
                while ((fixedIndex = affectedSection.indexOf("\"fixed\"", fixedIndex)) != -1) {
                    int start = affectedSection.indexOf("\"", fixedIndex + 8);
                    if (start != -1) {
                        int end = affectedSection.indexOf("\"", start + 1);
                        if (end != -1) {
                            String fixedVersion = affectedSection.substring(start + 1, end);
                            if (!fixedVersions.contains(fixedVersion)) {
                                fixedVersions.add(fixedVersion);
                            }
                        }
                    }
                    fixedIndex += 8;
                }
            }
            
            // Get vulnerability summary
            int summaryIndex = json.indexOf("\"summary\"");
            if (summaryIndex != -1) {
                int start = json.indexOf("\"", summaryIndex + 10);
                if (start != -1) {
                    int end = json.indexOf("\"", start + 1);
                    if (end != -1) {
                        String vulnSummary = json.substring(start + 1, end);
                        summary.append(vulnSummary);
                    }
                }
            }
            
        } catch (Exception e) {
            System.err.println("Error parsing remediation info: " + e.getMessage());
        }
        
        if (fixedVersions.isEmpty()) {
            return RemediationInfo.empty();
        }
        
        return new RemediationInfo(fixedVersions, summary.toString());
    }

    private static String extractLatestVersion(String json) {
        // Simple JSON parsing without external dependencies
        int vIndex = json.indexOf("\"latestVersion\":\"");
        if (vIndex == -1) return null;
        
        int start = vIndex + 17; // length of "latestVersion":"
        int end = json.indexOf("\"", start);
        if (end == -1) return null;
        
        return json.substring(start, end);
    }
}
